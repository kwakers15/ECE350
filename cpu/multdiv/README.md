# MultDiv
## Name
Minjun Kwak
## Description of Design
At the top level multdiv module, I created two submodules, a multiplier and a divider, which are used to calculate the result of the multiplication and division operations respectively. An SR latch is used at this top level to store the last seen control signal - it stores a 1 if a ctrl_MULT signal was last seen, and a 0 if a ctrl_DIV signal was last seen. This is done through having the ctrl_MULT signal be the Set input, and the ctrl_DIV signal be the Reset input. We know that at most one control signal will be high at any time, so this guarantees that the output of the SR latch will always be well defined. This output is fed into a 2-input MUX to determine whether the multiplication result or the division result (and their exception signals) should be fed as the output of the multdiv module.

The multiplier submodule takes in both ctrl signals as inputs. This is done to guarantee that the data_resultRDY signal will only go high when the last seen control signal was a ctrl_MULT signal, because when the ctrl_DIV signal goes high, the multiplier submodule will reset its T flip flop counter and the SR latch that tell the counter to start counting. The data_resultRDY signal will only go high once the T flip flop counter reaches four, so if the ctrl_DIV signal is asserted before this count, everything will be reset and the interrupt will be executed smoothly. Besides this control logic, the multiplier is a classic Wallace Tree implementation that computes the partial products associated with each bit position and uses full adders or half adders to compute the sums of either two or three partial products. This is done in a cascading manner, such that once there are only two (or one) partial products remaining at each bit position, we can compute the final result of the multiply operation using a 32-bit CLA adder. A counter is used to stall the logic so that the resultRDY signal will only be asserted after four clock cycles since the ctrl_MULT signal went high, and an SR Latch guards the enable inputs of each T flip flop such that counting only happens once the ctrl_MULT goes high.

The divider submodule has control logic that works extremely similarly to the multiplier submodule. It also takes in both ctrl signals as inputs, so that when a ctrl_MULT is asserted, the T flip flop counter is reset to 0 and the SR Latch guarding the counter outputs 0 such that counting is stopped. This protects against the possibility of a division resultRDY being asserted when the ctrl_MULT signal was the last seen control signal, because counting will have stopped when the control signal wen high, and the division resultRDY signal only goes high once the counter reaches 35. The implementation of the divider follows the non-restoring algorithm discussed in lecture. At each increment of the counter, the divider will use registers to update the value of the currently computed result and feed it back into the data input of the register. The update includes a left shift of the result, an add/subtract operation at the 32 MSB using a CLA adder, and an assignment of the LSB depending on the result of the add/subtract operation. At the moment the counter reaches 33 the result is computed, but I spend an extra clock cycle checking to see whether the result to be latched into the result register should be the negative of the computed result (because the algorithm only works for unsigned numbers). The actual result is then latched into the register at counter = 34, and then the data_resultRDY is asserted at counter = 35.
## Bugs
No bugs detected.